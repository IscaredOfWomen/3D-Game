<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>3D Parkour Level - Room Movement with Slide Cooldown</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>

<script src="https://cdn.jsdelivr.net/npm/three@0.130.1/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.130.1/examples/js/controls/PointerLockControls.js"></script>

<script>
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87CEEB);
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const light = new THREE.DirectionalLight(0xffffff, 1);
  light.position.set(10, 50, 10);
  scene.add(light);
  scene.add(new THREE.AmbientLight(0x404040));

  const roomWidth = 50;
  const roomHeight = 20;
  const roomDepth = 50;
  const wallMaterial = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, side: THREE.BackSide });
  const room = new THREE.Mesh(
    new THREE.BoxGeometry(roomWidth, roomHeight, roomDepth),
    wallMaterial
  );
  room.position.set(0, roomHeight / 2, 0);
  scene.add(room);

  // Capsule settings
  const standingHeight = 1.6;
  const crouchHeight = 0.8;
  const capsuleRadius = 0.5;
  const spawnPosition = new THREE.Vector3(0, 2, 0);
  const capsule = {
    start: spawnPosition.clone(),
    end: spawnPosition.clone().add(new THREE.Vector3(0, standingHeight, 0)),
    radius: capsuleRadius,
    currentHeight: standingHeight
  };

  const controls = new THREE.PointerLockControls(camera, renderer.domElement);
  document.body.addEventListener('click', () => controls.lock());

  let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
  let isJumping = false;
  let isCrouching = false;
  let isSliding = false;
  let slideTimer = 0;
  const maxSlideTime = 0.6; // seconds
  const slideSpeed = 0.6;   // starting slide speed
  let velocityY = 0;
  let moveSpeed = 0.25;  // normal speed

  let slideCooldown = 0;  // cooldown timer in seconds
  const slideCooldownDuration = 0.3;

  const heightAdjustSpeed = 0.1;
  const slideCameraOffset = 0.6; // how much lower camera moves during slide

  // To track shift key pressed state
  let shiftPressed = false;

  document.addEventListener('keydown', (event) => {
    const key = event.key.toLowerCase();
    if (event.ctrlKey && ['w', 'a', 's', 'd'].includes(key)) {
      event.preventDefault();
    }
    if (key === 'w') moveForward = true;
    if (key === 's') moveBackward = true;
    if (key === 'a') moveLeft = true;
    if (key === 'd') moveRight = true;

    if (event.key === ' ') {
      if (!isJumping && !isSliding) {
        velocityY = 0.3;
        isJumping = true;
      }
    }

    if (event.key === 'Control') {
      isCrouching = true;
      // If crouching right after sliding cooldown ends, reset shiftPressed so slide won't restart
      if (slideCooldown > 0 && !isSliding) {
        shiftPressed = false;
      }
    }

    if (event.key === 'Shift') {
      shiftPressed = true;
      if ((moveForward || moveBackward || moveLeft || moveRight) && !isSliding && !isCrouching && slideCooldown <= 0) {
        isSliding = true;
        slideTimer = maxSlideTime;
      }
    }
  });

  document.addEventListener('keyup', (event) => {
    if (event.key === 'w') moveForward = false;
    if (event.key === 's') moveBackward = false;
    if (event.key === 'a') moveLeft = false;
    if (event.key === 'd') moveRight = false;
    if (event.key === 'Control') isCrouching = false;
    if (event.key === 'Shift') {
      shiftPressed = false;
    }
  });

  function checkCollisions() {
    let onGround = false;

    // Floor collision
    if (capsule.start.y <= capsuleRadius) {
      const height = capsule.end.y - capsule.start.y;
      capsule.start.y = capsuleRadius;
      capsule.end.y = capsule.start.y + height;
      velocityY = 0;
      isJumping = false;
      onGround = true;
    }

    // Ceiling collision
    if (capsule.end.y >= roomHeight) {
      const height = capsule.end.y - capsule.start.y;
      capsule.end.y = roomHeight;
      capsule.start.y = capsule.end.y - height;
      velocityY = Math.min(velocityY, 0);
    }

    // Wall collisions (x and z)
    const halfWidth = roomWidth / 2 - capsuleRadius;
    const halfDepth = roomDepth / 2 - capsuleRadius;

    for (let point of [capsule.start, capsule.end]) {
      point.x = Math.max(-halfWidth, Math.min(halfWidth, point.x));
      point.z = Math.max(-halfDepth, Math.min(halfDepth, point.z));
    }

    return onGround;
  }

  function animate() {
    setTimeout(() => {
      requestAnimationFrame(animate);

      // Handle slide cooldown timer
      if (!isSliding && slideCooldown > 0) {
        slideCooldown -= 1 / 60;
        if (slideCooldown < 0) slideCooldown = 0;
      }

      // Smoothly adjust capsule height for crouch/stand
      const targetHeight = isCrouching ? crouchHeight : standingHeight;
      if (Math.abs(capsule.currentHeight - targetHeight) > 0.01) {
        capsule.currentHeight += (targetHeight - capsule.currentHeight) * heightAdjustSpeed;
        capsule.end.y = capsule.start.y + capsule.currentHeight;
      } else {
        capsule.currentHeight = targetHeight;
      }

      // Sliding speed logic with smooth slow down
      if (isSliding) {
        const slideProgress = 1 - slideTimer / maxSlideTime; // 0 to 1
        moveSpeed = slideSpeed * (1 - slideProgress) + 0.12 * slideProgress;

        slideTimer -= 1 / 60;
        if (slideTimer <= 0 || !(moveForward || moveBackward || moveLeft || moveRight)) {
          isSliding = false;
          slideCooldown = slideCooldownDuration;
          shiftPressed = false; // reset shift state so slide can't restart from held key
        }
      } else {
        moveSpeed = isCrouching ? 0.12 : 0.25;
      }

      // Gravity
      velocityY -= 0.0125;
      capsule.start.y += velocityY;
      capsule.end.y += velocityY;

      const onGround = checkCollisions();

      if (!onGround && capsule.start.y < -50) {
        capsule.start.copy(spawnPosition);
        capsule.end.copy(spawnPosition).add(new THREE.Vector3(0, standingHeight, 0));
        velocityY = 0;
      }

      // Movement direction
      const direction = new THREE.Vector3();
      if (moveForward) direction.z -= 1;
      if (moveBackward) direction.z += 1;
      if (moveLeft) direction.x -= 1;
      if (moveRight) direction.x += 1;

      if (direction.lengthSq() > 0) {
        direction.normalize();
        direction.applyEuler(camera.rotation);

        const move = direction.multiplyScalar(moveSpeed);
        const newStart = capsule.start.clone().add(move);
        const newEnd = capsule.end.clone().add(move);

        const halfWidth = roomWidth / 2 - capsuleRadius;
        const halfDepth = roomDepth / 2 - capsuleRadius;

        if (
          Math.abs(newStart.x) <= halfWidth && Math.abs(newStart.z) <= halfDepth &&
          Math.abs(newEnd.x) <= halfWidth && Math.abs(newEnd.z) <= halfDepth
        ) {
          capsule.start.copy(newStart);
          capsule.end.copy(newEnd);
        }
      }

      // Camera position - base is capsule top minus crouch offset
      // Slide lowers camera further by slideCameraOffset smoothly
      const baseCamY = capsule.end.y - (standingHeight - capsule.currentHeight);
      let targetCamY = baseCamY;
      if (isSliding) {
        targetCamY -= slideCameraOffset;
      }
      // Smooth camera Y transition
      if (!camera.position.y) camera.position.y = targetCamY;
      camera.position.x = capsule.end.x;
      camera.position.z = capsule.end.z;
      camera.position.y += (targetCamY - camera.position.y) * 0.15;

      renderer.render(scene, camera);
    }, 1000 / 60);
  }

  animate();

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>

</body>
</html>
